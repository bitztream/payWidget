'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _object = require('object.assign');

var _object2 = _interopRequireDefault(_object);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactDom = require('react-dom');

var _reactDom2 = _interopRequireDefault(_reactDom);

var _server = require('react-dom/server');

var _server2 = _interopRequireDefault(_server);

var _shallow = require('react-test-renderer/shallow');

var _shallow2 = _interopRequireDefault(_shallow);

var _testUtils = require('react-dom/test-utils');

var _testUtils2 = _interopRequireDefault(_testUtils);

var _checkPropTypes2 = require('prop-types/checkPropTypes');

var _checkPropTypes3 = _interopRequireDefault(_checkPropTypes2);

var _reactIs = require('react-is');

var _enzyme = require('enzyme');

var _Utils = require('enzyme/build/Utils');

var _enzymeAdapterUtils = require('enzyme-adapter-utils');

var _reflection = require('react-reconciler/reflection');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /* eslint no-use-before-define: 0 */

// eslint-disable-next-line import/no-unresolved

// eslint-disable-next-line import/no-unresolved

// eslint-disable-next-line import/no-unresolved


var HostRoot = 3;
var ClassComponent = 2;
var FragmentType = 10;
var FunctionalComponent = 1;
var HostPortal = 4;
var HostComponent = 5;
var HostText = 6;
var Mode = 11;
var ContextConsumerType = 12;
var ContextProviderType = 13;
var ForwardRefType = 14;

function nodeAndSiblingsArray(nodeWithSibling) {
  var array = [];
  var node = nodeWithSibling;
  while (node != null) {
    array.push(node);
    node = node.sibling;
  }
  return array;
}

function flatten(arr) {
  var result = [];
  var stack = [{ i: 0, array: arr }];
  while (stack.length) {
    var n = stack.pop();
    while (n.i < n.array.length) {
      var el = n.array[n.i];
      n.i += 1;
      if (Array.isArray(el)) {
        stack.push(n);
        stack.push({ i: 0, array: el });
        break;
      }
      result.push(el);
    }
  }
  return result;
}

function nodeTypeFromType(type) {
  if (type === _reactIs.Portal) {
    return 'portal';
  }

  return (0, _enzymeAdapterUtils.nodeTypeFromType)(type);
}

function elementToTree(el) {
  if (!(0, _reactIs.isPortal)(el)) {
    return (0, _enzymeAdapterUtils.elementToTree)(el, elementToTree);
  }

  var children = el.children,
      containerInfo = el.containerInfo;

  var props = { children: children, containerInfo: containerInfo };

  return {
    nodeType: 'portal',
    type: _reactIs.Portal,
    props: props,
    key: (0, _enzymeAdapterUtils.ensureKeyOrUndefined)(el.key),
    ref: el.ref || null,
    instance: null,
    rendered: elementToTree(el.children)
  };
}

function _toTree(vnode) {
  if (vnode == null) {
    return null;
  }
  // TODO(lmr): I'm not really sure I understand whether or not this is what
  // i should be doing, or if this is a hack for something i'm doing wrong
  // somewhere else. Should talk to sebastian about this perhaps
  var node = (0, _reflection.findCurrentFiberUsingSlowPath)(vnode);
  switch (node.tag) {
    case HostRoot:
      // 3
      return childrenToTree(node.child);
    case HostPortal:
      {
        // 4
        var containerInfo = node.stateNode.containerInfo,
            children = node.memoizedProps;

        var props = { containerInfo: containerInfo, children: children };
        return {
          nodeType: 'portal',
          type: _reactIs.Portal,
          props: props,
          key: (0, _enzymeAdapterUtils.ensureKeyOrUndefined)(node.key),
          ref: node.ref,
          instance: null,
          rendered: childrenToTree(node.child)
        };
      }
    case ClassComponent:
      return {
        nodeType: 'class',
        type: node.type,
        props: (0, _object2['default'])({}, node.memoizedProps),
        key: (0, _enzymeAdapterUtils.ensureKeyOrUndefined)(node.key),
        ref: node.ref,
        instance: node.stateNode,
        rendered: childrenToTree(node.child)
      };
    case FunctionalComponent:
      // 1
      return {
        nodeType: 'function',
        type: node.type,
        props: (0, _object2['default'])({}, node.memoizedProps),
        key: (0, _enzymeAdapterUtils.ensureKeyOrUndefined)(node.key),
        ref: node.ref,
        instance: null,
        rendered: childrenToTree(node.child)
      };
    case HostComponent:
      {
        // 5
        var renderedNodes = flatten(nodeAndSiblingsArray(node.child).map(_toTree));
        if (renderedNodes.length === 0) {
          renderedNodes = [node.memoizedProps.children];
        }
        return {
          nodeType: 'host',
          type: node.type,
          props: (0, _object2['default'])({}, node.memoizedProps),
          key: (0, _enzymeAdapterUtils.ensureKeyOrUndefined)(node.key),
          ref: node.ref,
          instance: node.stateNode,
          rendered: renderedNodes
        };
      }
    case HostText:
      // 6
      return node.memoizedProps;
    case FragmentType: // 10
    case Mode: // 11
    case ContextProviderType: // 13
    case ContextConsumerType:
      // 12
      return childrenToTree(node.child);
    case ForwardRefType:
      {
        return {
          nodeType: 'function',
          type: node.type,
          props: (0, _object2['default'])({}, node.pendingProps),
          key: (0, _enzymeAdapterUtils.ensureKeyOrUndefined)(node.key),
          ref: node.ref,
          instance: null,
          rendered: childrenToTree(node.child)
        };
      }
    default:
      throw new Error('Enzyme Internal Error: unknown node with tag ' + String(node.tag));
  }
}

function childrenToTree(node) {
  if (!node) {
    return null;
  }
  var children = nodeAndSiblingsArray(node);
  if (children.length === 0) {
    return null;
  }
  if (children.length === 1) {
    return _toTree(children[0]);
  }
  return flatten(children.map(_toTree));
}

function _nodeToHostNode(_node) {
  // NOTE(lmr): node could be a function component
  // which wont have an instance prop, but we can get the
  // host node associated with its return value at that point.
  // Although this breaks down if the return value is an array,
  // as is possible with React 16.
  var node = _node;
  while (node && !Array.isArray(node) && node.instance === null) {
    node = node.rendered;
  }
  // if the SFC returned null effectively, there is no host node.
  if (!node) {
    return null;
  }

  var mapper = function mapper(item) {
    if (item && item.instance) return _reactDom2['default'].findDOMNode(item.instance);
    return null;
  };
  if (Array.isArray(node)) {
    return node.map(mapper);
  }
  if (Array.isArray(node.rendered) && node.nodeType === 'class') {
    return node.rendered.map(mapper);
  }
  return mapper(node);
}

function getProviderDefaultValue(Provider) {
  // React stores references to the Provider's defaultValue differently across versions.
  if ('_defaultValue' in Provider._context) {
    return Provider._context._defaultValue;
  }
  throw new Error('Enzyme Internal Error: can’t figure out how to get Provider’s default value');
}

function makeFakeElement(type) {
  return { $$typeof: _reactIs.Element, type: type };
}

var eventOptions = { animation: true };

var ReactSixteenThreeAdapter = function (_EnzymeAdapter) {
  _inherits(ReactSixteenThreeAdapter, _EnzymeAdapter);

  function ReactSixteenThreeAdapter() {
    _classCallCheck(this, ReactSixteenThreeAdapter);

    var _this = _possibleConstructorReturn(this, (ReactSixteenThreeAdapter.__proto__ || Object.getPrototypeOf(ReactSixteenThreeAdapter)).call(this));

    var lifecycles = _this.options.lifecycles;

    _this.options = (0, _object2['default'])({}, _this.options, {
      enableComponentDidUpdateOnSetState: true, // TODO: remove, semver-major
      legacyContextMode: 'parent',
      lifecycles: (0, _object2['default'])({}, lifecycles, {
        componentDidUpdate: {
          onSetState: true
        },
        getDerivedStateFromProps: {
          hasShouldComponentUpdateBug: true
        },
        getSnapshotBeforeUpdate: true,
        setState: {
          skipsComponentDidUpdateOnNullish: true
        },
        getChildContext: {
          calledByRenderer: false
        }
      })
    });
    return _this;
  }

  _createClass(ReactSixteenThreeAdapter, [{
    key: 'createMountRenderer',
    value: function () {
      function createMountRenderer(options) {
        (0, _enzymeAdapterUtils.assertDomAvailable)('mount');
        var attachTo = options.attachTo,
            hydrateIn = options.hydrateIn,
            wrappingComponentProps = options.wrappingComponentProps;

        var domNode = hydrateIn || attachTo || global.document.createElement('div');
        var instance = null;
        var adapter = this;
        return {
          render: function () {
            function render(el, context, callback) {
              if (instance === null) {
                var type = el.type,
                    props = el.props,
                    ref = el.ref;

                var wrapperProps = (0, _object2['default'])({
                  Component: type,
                  props: props,
                  wrappingComponentProps: wrappingComponentProps,
                  context: context
                }, ref && { refProp: ref });
                var ReactWrapperComponent = (0, _enzymeAdapterUtils.createMountWrapper)(el, (0, _object2['default'])({}, options, { adapter: adapter }));
                var wrappedEl = _react2['default'].createElement(ReactWrapperComponent, wrapperProps);
                instance = hydrateIn ? _reactDom2['default'].hydrate(wrappedEl, domNode) : _reactDom2['default'].render(wrappedEl, domNode);
                if (typeof callback === 'function') {
                  callback();
                }
              } else {
                instance.setChildProps(el.props, context, callback);
              }
            }

            return render;
          }(),
          unmount: function () {
            function unmount() {
              _reactDom2['default'].unmountComponentAtNode(domNode);
              instance = null;
            }

            return unmount;
          }(),
          getNode: function () {
            function getNode() {
              if (!instance) {
                return null;
              }
              return (0, _enzymeAdapterUtils.getNodeFromRootFinder)(adapter.isCustomComponent, _toTree(instance._reactInternalFiber), options);
            }

            return getNode;
          }(),
          simulateError: function () {
            function simulateError(nodeHierarchy, rootNode, error) {
              var _ref = nodeHierarchy.find(function (x) {
                return x.instance && x.instance.componentDidCatch;
              }) || {},
                  catchingInstance = _ref.instance;

              (0, _enzymeAdapterUtils.simulateError)(error, catchingInstance, rootNode, nodeHierarchy, nodeTypeFromType, adapter.displayNameOfNode);
            }

            return simulateError;
          }(),
          simulateEvent: function () {
            function simulateEvent(node, event, mock) {
              var mappedEvent = (0, _enzymeAdapterUtils.mapNativeEventNames)(event, eventOptions);
              var eventFn = _testUtils2['default'].Simulate[mappedEvent];
              if (!eventFn) {
                throw new TypeError('ReactWrapper::simulate() event \'' + String(event) + '\' does not exist');
              }
              // eslint-disable-next-line react/no-find-dom-node
              eventFn(adapter.nodeToHostNode(node), mock);
            }

            return simulateEvent;
          }(),
          batchedUpdates: function () {
            function batchedUpdates(fn) {
              return fn();
              // return ReactDOM.unstable_batchedUpdates(fn);
            }

            return batchedUpdates;
          }(),
          getWrappingComponentRenderer: function () {
            function getWrappingComponentRenderer() {
              return (0, _object2['default'])({}, this, (0, _enzymeAdapterUtils.getWrappingComponentMountRenderer)({
                toTree: function () {
                  function toTree(inst) {
                    return _toTree(inst._reactInternalFiber);
                  }

                  return toTree;
                }(),
                getMountWrapperInstance: function () {
                  function getMountWrapperInstance() {
                    return instance;
                  }

                  return getMountWrapperInstance;
                }()
              }));
            }

            return getWrappingComponentRenderer;
          }()
        };
      }

      return createMountRenderer;
    }()
  }, {
    key: 'createShallowRenderer',
    value: function () {
      function createShallowRenderer() /* options */{
        var adapter = this;
        var renderer = new _shallow2['default']();
        var isDOM = false;
        var cachedNode = null;
        return {
          render: function () {
            function render(el, context) {
              var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
                  _ref2$providerValues = _ref2.providerValues,
                  providerValues = _ref2$providerValues === undefined ? new Map() : _ref2$providerValues;

              cachedNode = el;
              /* eslint consistent-return: 0 */
              if (typeof el.type === 'string') {
                isDOM = true;
              } else if ((0, _reactIs.isContextProvider)(el)) {
                providerValues.set(el.type, el.props.value);
                var MockProvider = (0, _object2['default'])(function (props) {
                  return props.children;
                }, el.type);
                return (0, _enzymeAdapterUtils.withSetStateAllowed)(function () {
                  return renderer.render((0, _object2['default'])({}, el, { type: MockProvider }));
                });
              } else if ((0, _reactIs.isContextConsumer)(el)) {
                var Provider = adapter.getProviderFromConsumer(el.type);
                var value = providerValues.has(Provider) ? providerValues.get(Provider) : getProviderDefaultValue(Provider);
                var MockConsumer = (0, _object2['default'])(function (props) {
                  return props.children(value);
                }, el.type);
                return (0, _enzymeAdapterUtils.withSetStateAllowed)(function () {
                  return renderer.render((0, _object2['default'])({}, el, { type: MockConsumer }));
                });
              } else {
                isDOM = false;
                var Component = el.type;


                var isStateful = Component.prototype && (Component.prototype.isReactComponent || Array.isArray(Component.__reactAutoBindPairs) // fallback for createClass components
                );

                if (!isStateful && typeof Component === 'function') {
                  var wrappedEl = (0, _object2['default'])(function () {
                    return Component.apply(undefined, arguments);
                  }, // eslint-disable-line new-cap
                  Component);
                  return (0, _enzymeAdapterUtils.withSetStateAllowed)(function () {
                    return renderer.render((0, _object2['default'])({}, el, { type: wrappedEl }), context);
                  });
                }
                return (0, _enzymeAdapterUtils.withSetStateAllowed)(function () {
                  return renderer.render(el, context);
                });
              }
            }

            return render;
          }(),
          unmount: function () {
            function unmount() {
              renderer.unmount();
            }

            return unmount;
          }(),
          getNode: function () {
            function getNode() {
              if (isDOM) {
                return elementToTree(cachedNode);
              }
              var output = renderer.getRenderOutput();
              return {
                nodeType: nodeTypeFromType(cachedNode.type),
                type: cachedNode.type,
                props: cachedNode.props,
                key: (0, _enzymeAdapterUtils.ensureKeyOrUndefined)(cachedNode.key),
                ref: cachedNode.ref,
                instance: renderer._instance,
                rendered: Array.isArray(output) ? flatten(output).map(function (el) {
                  return elementToTree(el);
                }) : elementToTree(output)
              };
            }

            return getNode;
          }(),
          simulateError: function () {
            function simulateError(nodeHierarchy, rootNode, error) {
              (0, _enzymeAdapterUtils.simulateError)(error, renderer._instance, cachedNode, nodeHierarchy.concat(cachedNode), nodeTypeFromType, adapter.displayNameOfNode);
            }

            return simulateError;
          }(),
          simulateEvent: function () {
            function simulateEvent(node, event) {
              for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
                args[_key - 2] = arguments[_key];
              }

              var handler = node.props[(0, _enzymeAdapterUtils.propFromEvent)(event, eventOptions)];
              if (handler) {
                (0, _enzymeAdapterUtils.withSetStateAllowed)(function () {
                  // TODO(lmr): create/use synthetic events
                  // TODO(lmr): emulate React's event propagation
                  // ReactDOM.unstable_batchedUpdates(() => {
                  handler.apply(undefined, _toConsumableArray(args));
                  // });
                });
              }
            }

            return simulateEvent;
          }(),
          batchedUpdates: function () {
            function batchedUpdates(fn) {
              return fn();
              // return ReactDOM.unstable_batchedUpdates(fn);
            }

            return batchedUpdates;
          }(),
          checkPropTypes: function () {
            function checkPropTypes(typeSpecs, values, location, hierarchy) {
              return (0, _checkPropTypes3['default'])(typeSpecs, values, location, (0, _enzymeAdapterUtils.displayNameOfNode)(cachedNode), function () {
                return (0, _enzymeAdapterUtils.getComponentStack)(hierarchy.concat([cachedNode]));
              });
            }

            return checkPropTypes;
          }()
        };
      }

      return createShallowRenderer;
    }()
  }, {
    key: 'createStringRenderer',
    value: function () {
      function createStringRenderer(options) {
        return {
          render: function () {
            function render(el, context) {
              if (options.context && (el.type.contextTypes || options.childContextTypes)) {
                var childContextTypes = (0, _object2['default'])({}, el.type.contextTypes || {}, options.childContextTypes);
                var ContextWrapper = (0, _enzymeAdapterUtils.createRenderWrapper)(el, context, childContextTypes);
                return _server2['default'].renderToStaticMarkup(_react2['default'].createElement(ContextWrapper));
              }
              return _server2['default'].renderToStaticMarkup(el);
            }

            return render;
          }()
        };
      }

      return createStringRenderer;
    }()

    // Provided a bag of options, return an `EnzymeRenderer`. Some options can be implementation
    // specific, like `attach` etc. for React, but not part of this interface explicitly.
    // eslint-disable-next-line class-methods-use-this, no-unused-vars

  }, {
    key: 'createRenderer',
    value: function () {
      function createRenderer(options) {
        switch (options.mode) {
          case _enzyme.EnzymeAdapter.MODES.MOUNT:
            return this.createMountRenderer(options);
          case _enzyme.EnzymeAdapter.MODES.SHALLOW:
            return this.createShallowRenderer(options);
          case _enzyme.EnzymeAdapter.MODES.STRING:
            return this.createStringRenderer(options);
          default:
            throw new Error('Enzyme Internal Error: Unrecognized mode: ' + String(options.mode));
        }
      }

      return createRenderer;
    }()
  }, {
    key: 'wrap',
    value: function () {
      function wrap(element) {
        return (0, _enzymeAdapterUtils.wrap)(element);
      }

      return wrap;
    }()

    // converts an RSTNode to the corresponding JSX Pragma Element. This will be needed
    // in order to implement the `Wrapper.mount()` and `Wrapper.shallow()` methods, but should
    // be pretty straightforward for people to implement.
    // eslint-disable-next-line class-methods-use-this, no-unused-vars

  }, {
    key: 'nodeToElement',
    value: function () {
      function nodeToElement(node) {
        if (!node || (typeof node === 'undefined' ? 'undefined' : _typeof(node)) !== 'object') return null;
        return _react2['default'].createElement(node.type, (0, _enzymeAdapterUtils.propsWithKeysAndRef)(node));
      }

      return nodeToElement;
    }()
  }, {
    key: 'elementToNode',
    value: function () {
      function elementToNode(element) {
        return elementToTree(element);
      }

      return elementToNode;
    }()
  }, {
    key: 'nodeToHostNode',
    value: function () {
      function nodeToHostNode(node) {
        var supportsArray = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

        var nodes = _nodeToHostNode(node);
        if (Array.isArray(nodes) && !supportsArray) {
          return nodes[0];
        }
        return nodes;
      }

      return nodeToHostNode;
    }()
  }, {
    key: 'displayNameOfNode',
    value: function () {
      function displayNameOfNode(node) {
        if (!node) return null;
        var type = node.type,
            $$typeof = node.$$typeof;


        var nodeType = type || $$typeof;

        // newer node types may be undefined, so only test if the nodeType exists
        if (nodeType) {
          switch (nodeType) {
            case _reactIs.AsyncMode || NaN:
              return 'AsyncMode';
            case _reactIs.Fragment || NaN:
              return 'Fragment';
            case _reactIs.StrictMode || NaN:
              return 'StrictMode';
            case _reactIs.Portal || NaN:
              return 'Portal';
            default:
          }
        }

        var $$typeofType = type && type.$$typeof;

        switch ($$typeofType) {
          case _reactIs.ContextConsumer || NaN:
            return 'ContextConsumer';
          case _reactIs.ContextProvider || NaN:
            return 'ContextProvider';
          case _reactIs.ForwardRef || NaN:
            {
              if (type.displayName) {
                return type.displayName;
              }
              var name = (0, _enzymeAdapterUtils.displayNameOfNode)({ type: type.render });
              return name ? 'ForwardRef(' + String(name) + ')' : 'ForwardRef';
            }
          default:
            return (0, _enzymeAdapterUtils.displayNameOfNode)(node);
        }
      }

      return displayNameOfNode;
    }()
  }, {
    key: 'isValidElement',
    value: function () {
      function isValidElement(element) {
        return (0, _reactIs.isElement)(element);
      }

      return isValidElement;
    }()
  }, {
    key: 'isValidElementType',
    value: function () {
      function isValidElementType(object) {
        return !!object && (0, _reactIs.isValidElementType)(object);
      }

      return isValidElementType;
    }()
  }, {
    key: 'isFragment',
    value: function () {
      function isFragment(fragment) {
        return (0, _Utils.typeOfNode)(fragment) === _reactIs.Fragment;
      }

      return isFragment;
    }()
  }, {
    key: 'isCustomComponent',
    value: function () {
      function isCustomComponent(type) {
        var fakeElement = makeFakeElement(type);
        return !!type && (typeof type === 'function' || (0, _reactIs.isForwardRef)(fakeElement) || (0, _reactIs.isContextProvider)(fakeElement) || (0, _reactIs.isContextConsumer)(fakeElement));
      }

      return isCustomComponent;
    }()
  }, {
    key: 'isContextConsumer',
    value: function () {
      function isContextConsumer(type) {
        return !!type && (0, _reactIs.isContextConsumer)(makeFakeElement(type));
      }

      return isContextConsumer;
    }()
  }, {
    key: 'isCustomComponentElement',
    value: function () {
      function isCustomComponentElement(inst) {
        if (!inst || !this.isValidElement(inst)) {
          return false;
        }
        return this.isCustomComponent(inst.type);
      }

      return isCustomComponentElement;
    }()
  }, {
    key: 'getProviderFromConsumer',
    value: function () {
      function getProviderFromConsumer(Consumer) {
        var _ref3 = Consumer || {},
            Provider = _ref3.Provider;

        if (Provider) {
          return Provider;
        }
        throw new Error('Enzyme Internal Error: can’t figure out how to get Provider from Consumer');
      }

      return getProviderFromConsumer;
    }()
  }, {
    key: 'createElement',
    value: function () {
      function createElement() {
        return _react2['default'].createElement.apply(_react2['default'], arguments);
      }

      return createElement;
    }()
  }, {
    key: 'wrapWithWrappingComponent',
    value: function () {
      function wrapWithWrappingComponent(node, options) {
        return {
          RootFinder: _enzymeAdapterUtils.RootFinder,
          node: (0, _enzymeAdapterUtils.wrapWithWrappingComponent)(_react2['default'].createElement, node, options)
        };
      }

      return wrapWithWrappingComponent;
    }()
  }]);

  return ReactSixteenThreeAdapter;
}(_enzyme.EnzymeAdapter);

module.exports = ReactSixteenThreeAdapter;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9SZWFjdFNpeHRlZW5UaHJlZUFkYXB0ZXIuanMiXSwibmFtZXMiOlsiSG9zdFJvb3QiLCJDbGFzc0NvbXBvbmVudCIsIkZyYWdtZW50VHlwZSIsIkZ1bmN0aW9uYWxDb21wb25lbnQiLCJIb3N0UG9ydGFsIiwiSG9zdENvbXBvbmVudCIsIkhvc3RUZXh0IiwiTW9kZSIsIkNvbnRleHRDb25zdW1lclR5cGUiLCJDb250ZXh0UHJvdmlkZXJUeXBlIiwiRm9yd2FyZFJlZlR5cGUiLCJub2RlQW5kU2libGluZ3NBcnJheSIsIm5vZGVXaXRoU2libGluZyIsImFycmF5Iiwibm9kZSIsInB1c2giLCJzaWJsaW5nIiwiZmxhdHRlbiIsImFyciIsInJlc3VsdCIsInN0YWNrIiwiaSIsImxlbmd0aCIsIm4iLCJwb3AiLCJlbCIsIkFycmF5IiwiaXNBcnJheSIsIm5vZGVUeXBlRnJvbVR5cGUiLCJ0eXBlIiwiUG9ydGFsIiwiZWxlbWVudFRvVHJlZSIsImNoaWxkcmVuIiwiY29udGFpbmVySW5mbyIsInByb3BzIiwibm9kZVR5cGUiLCJrZXkiLCJyZWYiLCJpbnN0YW5jZSIsInJlbmRlcmVkIiwidG9UcmVlIiwidm5vZGUiLCJ0YWciLCJjaGlsZHJlblRvVHJlZSIsImNoaWxkIiwic3RhdGVOb2RlIiwibWVtb2l6ZWRQcm9wcyIsInJlbmRlcmVkTm9kZXMiLCJtYXAiLCJwZW5kaW5nUHJvcHMiLCJFcnJvciIsIm5vZGVUb0hvc3ROb2RlIiwiX25vZGUiLCJtYXBwZXIiLCJpdGVtIiwiUmVhY3RET00iLCJmaW5kRE9NTm9kZSIsImdldFByb3ZpZGVyRGVmYXVsdFZhbHVlIiwiUHJvdmlkZXIiLCJfY29udGV4dCIsIl9kZWZhdWx0VmFsdWUiLCJtYWtlRmFrZUVsZW1lbnQiLCIkJHR5cGVvZiIsIkVsZW1lbnQiLCJldmVudE9wdGlvbnMiLCJhbmltYXRpb24iLCJSZWFjdFNpeHRlZW5UaHJlZUFkYXB0ZXIiLCJsaWZlY3ljbGVzIiwib3B0aW9ucyIsImVuYWJsZUNvbXBvbmVudERpZFVwZGF0ZU9uU2V0U3RhdGUiLCJsZWdhY3lDb250ZXh0TW9kZSIsImNvbXBvbmVudERpZFVwZGF0ZSIsIm9uU2V0U3RhdGUiLCJnZXREZXJpdmVkU3RhdGVGcm9tUHJvcHMiLCJoYXNTaG91bGRDb21wb25lbnRVcGRhdGVCdWciLCJnZXRTbmFwc2hvdEJlZm9yZVVwZGF0ZSIsInNldFN0YXRlIiwic2tpcHNDb21wb25lbnREaWRVcGRhdGVPbk51bGxpc2giLCJnZXRDaGlsZENvbnRleHQiLCJjYWxsZWRCeVJlbmRlcmVyIiwiYXR0YWNoVG8iLCJoeWRyYXRlSW4iLCJ3cmFwcGluZ0NvbXBvbmVudFByb3BzIiwiZG9tTm9kZSIsImdsb2JhbCIsImRvY3VtZW50IiwiY3JlYXRlRWxlbWVudCIsImFkYXB0ZXIiLCJyZW5kZXIiLCJjb250ZXh0IiwiY2FsbGJhY2siLCJ3cmFwcGVyUHJvcHMiLCJDb21wb25lbnQiLCJyZWZQcm9wIiwiUmVhY3RXcmFwcGVyQ29tcG9uZW50Iiwid3JhcHBlZEVsIiwiUmVhY3QiLCJoeWRyYXRlIiwic2V0Q2hpbGRQcm9wcyIsInVubW91bnQiLCJ1bm1vdW50Q29tcG9uZW50QXROb2RlIiwiZ2V0Tm9kZSIsImlzQ3VzdG9tQ29tcG9uZW50IiwiX3JlYWN0SW50ZXJuYWxGaWJlciIsInNpbXVsYXRlRXJyb3IiLCJub2RlSGllcmFyY2h5Iiwicm9vdE5vZGUiLCJlcnJvciIsImZpbmQiLCJ4IiwiY29tcG9uZW50RGlkQ2F0Y2giLCJjYXRjaGluZ0luc3RhbmNlIiwiZGlzcGxheU5hbWVPZk5vZGUiLCJzaW11bGF0ZUV2ZW50IiwiZXZlbnQiLCJtb2NrIiwibWFwcGVkRXZlbnQiLCJldmVudEZuIiwiVGVzdFV0aWxzIiwiU2ltdWxhdGUiLCJUeXBlRXJyb3IiLCJiYXRjaGVkVXBkYXRlcyIsImZuIiwiZ2V0V3JhcHBpbmdDb21wb25lbnRSZW5kZXJlciIsImluc3QiLCJnZXRNb3VudFdyYXBwZXJJbnN0YW5jZSIsInJlbmRlcmVyIiwiU2hhbGxvd1JlbmRlcmVyIiwiaXNET00iLCJjYWNoZWROb2RlIiwicHJvdmlkZXJWYWx1ZXMiLCJNYXAiLCJzZXQiLCJ2YWx1ZSIsIk1vY2tQcm92aWRlciIsImdldFByb3ZpZGVyRnJvbUNvbnN1bWVyIiwiaGFzIiwiZ2V0IiwiTW9ja0NvbnN1bWVyIiwiaXNTdGF0ZWZ1bCIsInByb3RvdHlwZSIsImlzUmVhY3RDb21wb25lbnQiLCJfX3JlYWN0QXV0b0JpbmRQYWlycyIsIm91dHB1dCIsImdldFJlbmRlck91dHB1dCIsIl9pbnN0YW5jZSIsImNvbmNhdCIsImFyZ3MiLCJoYW5kbGVyIiwiY2hlY2tQcm9wVHlwZXMiLCJ0eXBlU3BlY3MiLCJ2YWx1ZXMiLCJsb2NhdGlvbiIsImhpZXJhcmNoeSIsImNvbnRleHRUeXBlcyIsImNoaWxkQ29udGV4dFR5cGVzIiwiQ29udGV4dFdyYXBwZXIiLCJSZWFjdERPTVNlcnZlciIsInJlbmRlclRvU3RhdGljTWFya3VwIiwibW9kZSIsIkVuenltZUFkYXB0ZXIiLCJNT0RFUyIsIk1PVU5UIiwiY3JlYXRlTW91bnRSZW5kZXJlciIsIlNIQUxMT1ciLCJjcmVhdGVTaGFsbG93UmVuZGVyZXIiLCJTVFJJTkciLCJjcmVhdGVTdHJpbmdSZW5kZXJlciIsImVsZW1lbnQiLCJzdXBwb3J0c0FycmF5Iiwibm9kZXMiLCJBc3luY01vZGUiLCJOYU4iLCJGcmFnbWVudCIsIlN0cmljdE1vZGUiLCIkJHR5cGVvZlR5cGUiLCJDb250ZXh0Q29uc3VtZXIiLCJDb250ZXh0UHJvdmlkZXIiLCJGb3J3YXJkUmVmIiwiZGlzcGxheU5hbWUiLCJuYW1lIiwib2JqZWN0IiwiZnJhZ21lbnQiLCJmYWtlRWxlbWVudCIsImlzVmFsaWRFbGVtZW50IiwiQ29uc3VtZXIiLCJSb290RmluZGVyIiwibW9kdWxlIiwiZXhwb3J0cyJdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUNBOzs7O0FBQ0E7Ozs7QUFFQTs7OztBQUVBOzs7O0FBRUE7Ozs7QUFDQTs7OztBQUNBOztBQWdCQTs7QUFDQTs7QUFDQTs7QUFvQkE7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Ozt5Q0FFeUJ4RSxJLEVBQU1zRCxPLEVBQVM7QUFDdkMsZUFBTztBQUNMc0gsb0RBREs7QUFFTDVLLGdCQUFNLG1EQUEwQmtGLG1CQUFNVixhQUFoQyxFQUErQ3hFLElBQS9DLEVBQXFEc0QsT0FBckQ7QUFGRCxTQUFQO0FBSUQ7Ozs7Ozs7RUFoV29DNEYscUI7O0FBbVd2QzJCLE9BQU9DLE9BQVAsR0FBaUIxSCx3QkFBakIiLCJmaWxlIjoiUmVhY3RTaXh0ZWVuVGhyZWVBZGFwdGVyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50IG5vLXVzZS1iZWZvcmUtZGVmaW5lOiAwICovXG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IFJlYWN0RE9NIGZyb20gJ3JlYWN0LWRvbSc7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVucmVzb2x2ZWRcbmltcG9ydCBSZWFjdERPTVNlcnZlciBmcm9tICdyZWFjdC1kb20vc2VydmVyJztcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW5yZXNvbHZlZFxuaW1wb3J0IFNoYWxsb3dSZW5kZXJlciBmcm9tICdyZWFjdC10ZXN0LXJlbmRlcmVyL3NoYWxsb3cnO1xuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnJlc29sdmVkXG5pbXBvcnQgVGVzdFV0aWxzIGZyb20gJ3JlYWN0LWRvbS90ZXN0LXV0aWxzJztcbmltcG9ydCBjaGVja1Byb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzL2NoZWNrUHJvcFR5cGVzJztcbmltcG9ydCB7XG4gIEFzeW5jTW9kZSxcbiAgQ29udGV4dENvbnN1bWVyLFxuICBDb250ZXh0UHJvdmlkZXIsXG4gIEVsZW1lbnQsXG4gIEZvcndhcmRSZWYsXG4gIEZyYWdtZW50LFxuICBpc0NvbnRleHRDb25zdW1lcixcbiAgaXNDb250ZXh0UHJvdmlkZXIsXG4gIGlzRWxlbWVudCxcbiAgaXNGb3J3YXJkUmVmLFxuICBpc1BvcnRhbCxcbiAgaXNWYWxpZEVsZW1lbnRUeXBlLFxuICBQb3J0YWwsXG4gIFN0cmljdE1vZGUsXG59IGZyb20gJ3JlYWN0LWlzJztcbmltcG9ydCB7IEVuenltZUFkYXB0ZXIgfSBmcm9tICdlbnp5bWUnO1xuaW1wb3J0IHsgdHlwZU9mTm9kZSB9IGZyb20gJ2VuenltZS9idWlsZC9VdGlscyc7XG5pbXBvcnQge1xuICBkaXNwbGF5TmFtZU9mTm9kZSxcbiAgZWxlbWVudFRvVHJlZSBhcyB1dGlsRWxlbWVudFRvVHJlZSxcbiAgbm9kZVR5cGVGcm9tVHlwZSBhcyB1dGlsTm9kZVR5cGVGcm9tVHlwZSxcbiAgbWFwTmF0aXZlRXZlbnROYW1lcyxcbiAgcHJvcEZyb21FdmVudCxcbiAgYXNzZXJ0RG9tQXZhaWxhYmxlLFxuICB3aXRoU2V0U3RhdGVBbGxvd2VkLFxuICBjcmVhdGVSZW5kZXJXcmFwcGVyLFxuICBjcmVhdGVNb3VudFdyYXBwZXIsXG4gIHByb3BzV2l0aEtleXNBbmRSZWYsXG4gIGVuc3VyZUtleU9yVW5kZWZpbmVkLFxuICBzaW11bGF0ZUVycm9yLFxuICB3cmFwLFxuICBnZXRDb21wb25lbnRTdGFjayxcbiAgUm9vdEZpbmRlcixcbiAgZ2V0Tm9kZUZyb21Sb290RmluZGVyLFxuICB3cmFwV2l0aFdyYXBwaW5nQ29tcG9uZW50LFxuICBnZXRXcmFwcGluZ0NvbXBvbmVudE1vdW50UmVuZGVyZXIsXG59IGZyb20gJ2VuenltZS1hZGFwdGVyLXV0aWxzJztcbmltcG9ydCB7IGZpbmRDdXJyZW50RmliZXJVc2luZ1Nsb3dQYXRoIH0gZnJvbSAncmVhY3QtcmVjb25jaWxlci9yZWZsZWN0aW9uJztcblxuY29uc3QgSG9zdFJvb3QgPSAzO1xuY29uc3QgQ2xhc3NDb21wb25lbnQgPSAyO1xuY29uc3QgRnJhZ21lbnRUeXBlID0gMTA7XG5jb25zdCBGdW5jdGlvbmFsQ29tcG9uZW50ID0gMTtcbmNvbnN0IEhvc3RQb3J0YWwgPSA0O1xuY29uc3QgSG9zdENvbXBvbmVudCA9IDU7XG5jb25zdCBIb3N0VGV4dCA9IDY7XG5jb25zdCBNb2RlID0gMTE7XG5jb25zdCBDb250ZXh0Q29uc3VtZXJUeXBlID0gMTI7XG5jb25zdCBDb250ZXh0UHJvdmlkZXJUeXBlID0gMTM7XG5jb25zdCBGb3J3YXJkUmVmVHlwZSA9IDE0O1xuXG5mdW5jdGlvbiBub2RlQW5kU2libGluZ3NBcnJheShub2RlV2l0aFNpYmxpbmcpIHtcbiAgY29uc3QgYXJyYXkgPSBbXTtcbiAgbGV0IG5vZGUgPSBub2RlV2l0aFNpYmxpbmc7XG4gIHdoaWxlIChub2RlICE9IG51bGwpIHtcbiAgICBhcnJheS5wdXNoKG5vZGUpO1xuICAgIG5vZGUgPSBub2RlLnNpYmxpbmc7XG4gIH1cbiAgcmV0dXJuIGFycmF5O1xufVxuXG5mdW5jdGlvbiBmbGF0dGVuKGFycikge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgY29uc3Qgc3RhY2sgPSBbeyBpOiAwLCBhcnJheTogYXJyIH1dO1xuICB3aGlsZSAoc3RhY2subGVuZ3RoKSB7XG4gICAgY29uc3QgbiA9IHN0YWNrLnBvcCgpO1xuICAgIHdoaWxlIChuLmkgPCBuLmFycmF5Lmxlbmd0aCkge1xuICAgICAgY29uc3QgZWwgPSBuLmFycmF5W24uaV07XG4gICAgICBuLmkgKz0gMTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KGVsKSkge1xuICAgICAgICBzdGFjay5wdXNoKG4pO1xuICAgICAgICBzdGFjay5wdXNoKHsgaTogMCwgYXJyYXk6IGVsIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5wdXNoKGVsKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gbm9kZVR5cGVGcm9tVHlwZSh0eXBlKSB7XG4gIGlmICh0eXBlID09PSBQb3J0YWwpIHtcbiAgICByZXR1cm4gJ3BvcnRhbCc7XG4gIH1cblxuICByZXR1cm4gdXRpbE5vZGVUeXBlRnJvbVR5cGUodHlwZSk7XG59XG5cbmZ1bmN0aW9uIGVsZW1lbnRUb1RyZWUoZWwpIHtcbiAgaWYgKCFpc1BvcnRhbChlbCkpIHtcbiAgICByZXR1cm4gdXRpbEVsZW1lbnRUb1RyZWUoZWwsIGVsZW1lbnRUb1RyZWUpO1xuICB9XG5cbiAgY29uc3QgeyBjaGlsZHJlbiwgY29udGFpbmVySW5mbyB9ID0gZWw7XG4gIGNvbnN0IHByb3BzID0geyBjaGlsZHJlbiwgY29udGFpbmVySW5mbyB9O1xuXG4gIHJldHVybiB7XG4gICAgbm9kZVR5cGU6ICdwb3J0YWwnLFxuICAgIHR5cGU6IFBvcnRhbCxcbiAgICBwcm9wcyxcbiAgICBrZXk6IGVuc3VyZUtleU9yVW5kZWZpbmVkKGVsLmtleSksXG4gICAgcmVmOiBlbC5yZWYgfHwgbnVsbCxcbiAgICBpbnN0YW5jZTogbnVsbCxcbiAgICByZW5kZXJlZDogZWxlbWVudFRvVHJlZShlbC5jaGlsZHJlbiksXG4gIH07XG59XG5cbmZ1bmN0aW9uIHRvVHJlZSh2bm9kZSkge1xuICBpZiAodm5vZGUgPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIC8vIFRPRE8obG1yKTogSSdtIG5vdCByZWFsbHkgc3VyZSBJIHVuZGVyc3RhbmQgd2hldGhlciBvciBub3QgdGhpcyBpcyB3aGF0XG4gIC8vIGkgc2hvdWxkIGJlIGRvaW5nLCBvciBpZiB0aGlzIGlzIGEgaGFjayBmb3Igc29tZXRoaW5nIGknbSBkb2luZyB3cm9uZ1xuICAvLyBzb21ld2hlcmUgZWxzZS4gU2hvdWxkIHRhbGsgdG8gc2ViYXN0aWFuIGFib3V0IHRoaXMgcGVyaGFwc1xuICBjb25zdCBub2RlID0gZmluZEN1cnJlbnRGaWJlclVzaW5nU2xvd1BhdGgodm5vZGUpO1xuICBzd2l0Y2ggKG5vZGUudGFnKSB7XG4gICAgY2FzZSBIb3N0Um9vdDogLy8gM1xuICAgICAgcmV0dXJuIGNoaWxkcmVuVG9UcmVlKG5vZGUuY2hpbGQpO1xuICAgIGNhc2UgSG9zdFBvcnRhbDogeyAvLyA0XG4gICAgICBjb25zdCB7XG4gICAgICAgIHN0YXRlTm9kZTogeyBjb250YWluZXJJbmZvIH0sXG4gICAgICAgIG1lbW9pemVkUHJvcHM6IGNoaWxkcmVuLFxuICAgICAgfSA9IG5vZGU7XG4gICAgICBjb25zdCBwcm9wcyA9IHsgY29udGFpbmVySW5mbywgY2hpbGRyZW4gfTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5vZGVUeXBlOiAncG9ydGFsJyxcbiAgICAgICAgdHlwZTogUG9ydGFsLFxuICAgICAgICBwcm9wcyxcbiAgICAgICAga2V5OiBlbnN1cmVLZXlPclVuZGVmaW5lZChub2RlLmtleSksXG4gICAgICAgIHJlZjogbm9kZS5yZWYsXG4gICAgICAgIGluc3RhbmNlOiBudWxsLFxuICAgICAgICByZW5kZXJlZDogY2hpbGRyZW5Ub1RyZWUobm9kZS5jaGlsZCksXG4gICAgICB9O1xuICAgIH1cbiAgICBjYXNlIENsYXNzQ29tcG9uZW50OlxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbm9kZVR5cGU6ICdjbGFzcycsXG4gICAgICAgIHR5cGU6IG5vZGUudHlwZSxcbiAgICAgICAgcHJvcHM6IHsgLi4ubm9kZS5tZW1vaXplZFByb3BzIH0sXG4gICAgICAgIGtleTogZW5zdXJlS2V5T3JVbmRlZmluZWQobm9kZS5rZXkpLFxuICAgICAgICByZWY6IG5vZGUucmVmLFxuICAgICAgICBpbnN0YW5jZTogbm9kZS5zdGF0ZU5vZGUsXG4gICAgICAgIHJlbmRlcmVkOiBjaGlsZHJlblRvVHJlZShub2RlLmNoaWxkKSxcbiAgICAgIH07XG4gICAgY2FzZSBGdW5jdGlvbmFsQ29tcG9uZW50OiAvLyAxXG4gICAgICByZXR1cm4ge1xuICAgICAgICBub2RlVHlwZTogJ2Z1bmN0aW9uJyxcbiAgICAgICAgdHlwZTogbm9kZS50eXBlLFxuICAgICAgICBwcm9wczogeyAuLi5ub2RlLm1lbW9pemVkUHJvcHMgfSxcbiAgICAgICAga2V5OiBlbnN1cmVLZXlPclVuZGVmaW5lZChub2RlLmtleSksXG4gICAgICAgIHJlZjogbm9kZS5yZWYsXG4gICAgICAgIGluc3RhbmNlOiBudWxsLFxuICAgICAgICByZW5kZXJlZDogY2hpbGRyZW5Ub1RyZWUobm9kZS5jaGlsZCksXG4gICAgICB9O1xuICAgIGNhc2UgSG9zdENvbXBvbmVudDogeyAvLyA1XG4gICAgICBsZXQgcmVuZGVyZWROb2RlcyA9IGZsYXR0ZW4obm9kZUFuZFNpYmxpbmdzQXJyYXkobm9kZS5jaGlsZCkubWFwKHRvVHJlZSkpO1xuICAgICAgaWYgKHJlbmRlcmVkTm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJlbmRlcmVkTm9kZXMgPSBbbm9kZS5tZW1vaXplZFByb3BzLmNoaWxkcmVuXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5vZGVUeXBlOiAnaG9zdCcsXG4gICAgICAgIHR5cGU6IG5vZGUudHlwZSxcbiAgICAgICAgcHJvcHM6IHsgLi4ubm9kZS5tZW1vaXplZFByb3BzIH0sXG4gICAgICAgIGtleTogZW5zdXJlS2V5T3JVbmRlZmluZWQobm9kZS5rZXkpLFxuICAgICAgICByZWY6IG5vZGUucmVmLFxuICAgICAgICBpbnN0YW5jZTogbm9kZS5zdGF0ZU5vZGUsXG4gICAgICAgIHJlbmRlcmVkOiByZW5kZXJlZE5vZGVzLFxuICAgICAgfTtcbiAgICB9XG4gICAgY2FzZSBIb3N0VGV4dDogLy8gNlxuICAgICAgcmV0dXJuIG5vZGUubWVtb2l6ZWRQcm9wcztcbiAgICBjYXNlIEZyYWdtZW50VHlwZTogLy8gMTBcbiAgICBjYXNlIE1vZGU6IC8vIDExXG4gICAgY2FzZSBDb250ZXh0UHJvdmlkZXJUeXBlOiAvLyAxM1xuICAgIGNhc2UgQ29udGV4dENvbnN1bWVyVHlwZTogLy8gMTJcbiAgICAgIHJldHVybiBjaGlsZHJlblRvVHJlZShub2RlLmNoaWxkKTtcbiAgICBjYXNlIEZvcndhcmRSZWZUeXBlOiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBub2RlVHlwZTogJ2Z1bmN0aW9uJyxcbiAgICAgICAgdHlwZTogbm9kZS50eXBlLFxuICAgICAgICBwcm9wczogeyAuLi5ub2RlLnBlbmRpbmdQcm9wcyB9LFxuICAgICAgICBrZXk6IGVuc3VyZUtleU9yVW5kZWZpbmVkKG5vZGUua2V5KSxcbiAgICAgICAgcmVmOiBub2RlLnJlZixcbiAgICAgICAgaW5zdGFuY2U6IG51bGwsXG4gICAgICAgIHJlbmRlcmVkOiBjaGlsZHJlblRvVHJlZShub2RlLmNoaWxkKSxcbiAgICAgIH07XG4gICAgfVxuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEVuenltZSBJbnRlcm5hbCBFcnJvcjogdW5rbm93biBub2RlIHdpdGggdGFnICR7bm9kZS50YWd9YCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hpbGRyZW5Ub1RyZWUobm9kZSkge1xuICBpZiAoIW5vZGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBjaGlsZHJlbiA9IG5vZGVBbmRTaWJsaW5nc0FycmF5KG5vZGUpO1xuICBpZiAoY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgaWYgKGNoaWxkcmVuLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiB0b1RyZWUoY2hpbGRyZW5bMF0pO1xuICB9XG4gIHJldHVybiBmbGF0dGVuKGNoaWxkcmVuLm1hcCh0b1RyZWUpKTtcbn1cblxuZnVuY3Rpb24gbm9kZVRvSG9zdE5vZGUoX25vZGUpIHtcbiAgLy8gTk9URShsbXIpOiBub2RlIGNvdWxkIGJlIGEgZnVuY3Rpb24gY29tcG9uZW50XG4gIC8vIHdoaWNoIHdvbnQgaGF2ZSBhbiBpbnN0YW5jZSBwcm9wLCBidXQgd2UgY2FuIGdldCB0aGVcbiAgLy8gaG9zdCBub2RlIGFzc29jaWF0ZWQgd2l0aCBpdHMgcmV0dXJuIHZhbHVlIGF0IHRoYXQgcG9pbnQuXG4gIC8vIEFsdGhvdWdoIHRoaXMgYnJlYWtzIGRvd24gaWYgdGhlIHJldHVybiB2YWx1ZSBpcyBhbiBhcnJheSxcbiAgLy8gYXMgaXMgcG9zc2libGUgd2l0aCBSZWFjdCAxNi5cbiAgbGV0IG5vZGUgPSBfbm9kZTtcbiAgd2hpbGUgKG5vZGUgJiYgIUFycmF5LmlzQXJyYXkobm9kZSkgJiYgbm9kZS5pbnN0YW5jZSA9PT0gbnVsbCkge1xuICAgIG5vZGUgPSBub2RlLnJlbmRlcmVkO1xuICB9XG4gIC8vIGlmIHRoZSBTRkMgcmV0dXJuZWQgbnVsbCBlZmZlY3RpdmVseSwgdGhlcmUgaXMgbm8gaG9zdCBub2RlLlxuICBpZiAoIW5vZGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IG1hcHBlciA9IChpdGVtKSA9PiB7XG4gICAgaWYgKGl0ZW0gJiYgaXRlbS5pbnN0YW5jZSkgcmV0dXJuIFJlYWN0RE9NLmZpbmRET01Ob2RlKGl0ZW0uaW5zdGFuY2UpO1xuICAgIHJldHVybiBudWxsO1xuICB9O1xuICBpZiAoQXJyYXkuaXNBcnJheShub2RlKSkge1xuICAgIHJldHVybiBub2RlLm1hcChtYXBwZXIpO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KG5vZGUucmVuZGVyZWQpICYmIG5vZGUubm9kZVR5cGUgPT09ICdjbGFzcycpIHtcbiAgICByZXR1cm4gbm9kZS5yZW5kZXJlZC5tYXAobWFwcGVyKTtcbiAgfVxuICByZXR1cm4gbWFwcGVyKG5vZGUpO1xufVxuXG5mdW5jdGlvbiBnZXRQcm92aWRlckRlZmF1bHRWYWx1ZShQcm92aWRlcikge1xuICAvLyBSZWFjdCBzdG9yZXMgcmVmZXJlbmNlcyB0byB0aGUgUHJvdmlkZXIncyBkZWZhdWx0VmFsdWUgZGlmZmVyZW50bHkgYWNyb3NzIHZlcnNpb25zLlxuICBpZiAoJ19kZWZhdWx0VmFsdWUnIGluIFByb3ZpZGVyLl9jb250ZXh0KSB7XG4gICAgcmV0dXJuIFByb3ZpZGVyLl9jb250ZXh0Ll9kZWZhdWx0VmFsdWU7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKCdFbnp5bWUgSW50ZXJuYWwgRXJyb3I6IGNhbuKAmXQgZmlndXJlIG91dCBob3cgdG8gZ2V0IFByb3ZpZGVy4oCZcyBkZWZhdWx0IHZhbHVlJyk7XG59XG5cbmZ1bmN0aW9uIG1ha2VGYWtlRWxlbWVudCh0eXBlKSB7XG4gIHJldHVybiB7ICQkdHlwZW9mOiBFbGVtZW50LCB0eXBlIH07XG59XG5cbmNvbnN0IGV2ZW50T3B0aW9ucyA9IHsgYW5pbWF0aW9uOiB0cnVlIH07XG5cbmNsYXNzIFJlYWN0U2l4dGVlblRocmVlQWRhcHRlciBleHRlbmRzIEVuenltZUFkYXB0ZXIge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIGNvbnN0IHsgbGlmZWN5Y2xlcyB9ID0gdGhpcy5vcHRpb25zO1xuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgIC4uLnRoaXMub3B0aW9ucyxcbiAgICAgIGVuYWJsZUNvbXBvbmVudERpZFVwZGF0ZU9uU2V0U3RhdGU6IHRydWUsIC8vIFRPRE86IHJlbW92ZSwgc2VtdmVyLW1ham9yXG4gICAgICBsZWdhY3lDb250ZXh0TW9kZTogJ3BhcmVudCcsXG4gICAgICBsaWZlY3ljbGVzOiB7XG4gICAgICAgIC4uLmxpZmVjeWNsZXMsXG4gICAgICAgIGNvbXBvbmVudERpZFVwZGF0ZToge1xuICAgICAgICAgIG9uU2V0U3RhdGU6IHRydWUsXG4gICAgICAgIH0sXG4gICAgICAgIGdldERlcml2ZWRTdGF0ZUZyb21Qcm9wczoge1xuICAgICAgICAgIGhhc1Nob3VsZENvbXBvbmVudFVwZGF0ZUJ1ZzogdHJ1ZSxcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0U25hcHNob3RCZWZvcmVVcGRhdGU6IHRydWUsXG4gICAgICAgIHNldFN0YXRlOiB7XG4gICAgICAgICAgc2tpcHNDb21wb25lbnREaWRVcGRhdGVPbk51bGxpc2g6IHRydWUsXG4gICAgICAgIH0sXG4gICAgICAgIGdldENoaWxkQ29udGV4dDoge1xuICAgICAgICAgIGNhbGxlZEJ5UmVuZGVyZXI6IGZhbHNlLFxuICAgICAgICB9LFxuICAgICAgfSxcbiAgICB9O1xuICB9XG5cbiAgY3JlYXRlTW91bnRSZW5kZXJlcihvcHRpb25zKSB7XG4gICAgYXNzZXJ0RG9tQXZhaWxhYmxlKCdtb3VudCcpO1xuICAgIGNvbnN0IHsgYXR0YWNoVG8sIGh5ZHJhdGVJbiwgd3JhcHBpbmdDb21wb25lbnRQcm9wcyB9ID0gb3B0aW9ucztcbiAgICBjb25zdCBkb21Ob2RlID0gaHlkcmF0ZUluIHx8IGF0dGFjaFRvIHx8IGdsb2JhbC5kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBsZXQgaW5zdGFuY2UgPSBudWxsO1xuICAgIGNvbnN0IGFkYXB0ZXIgPSB0aGlzO1xuICAgIHJldHVybiB7XG4gICAgICByZW5kZXIoZWwsIGNvbnRleHQsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChpbnN0YW5jZSA9PT0gbnVsbCkge1xuICAgICAgICAgIGNvbnN0IHsgdHlwZSwgcHJvcHMsIHJlZiB9ID0gZWw7XG4gICAgICAgICAgY29uc3Qgd3JhcHBlclByb3BzID0ge1xuICAgICAgICAgICAgQ29tcG9uZW50OiB0eXBlLFxuICAgICAgICAgICAgcHJvcHMsXG4gICAgICAgICAgICB3cmFwcGluZ0NvbXBvbmVudFByb3BzLFxuICAgICAgICAgICAgY29udGV4dCxcbiAgICAgICAgICAgIC4uLihyZWYgJiYgeyByZWZQcm9wOiByZWYgfSksXG4gICAgICAgICAgfTtcbiAgICAgICAgICBjb25zdCBSZWFjdFdyYXBwZXJDb21wb25lbnQgPSBjcmVhdGVNb3VudFdyYXBwZXIoZWwsIHsgLi4ub3B0aW9ucywgYWRhcHRlciB9KTtcbiAgICAgICAgICBjb25zdCB3cmFwcGVkRWwgPSBSZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0V3JhcHBlckNvbXBvbmVudCwgd3JhcHBlclByb3BzKTtcbiAgICAgICAgICBpbnN0YW5jZSA9IGh5ZHJhdGVJblxuICAgICAgICAgICAgPyBSZWFjdERPTS5oeWRyYXRlKHdyYXBwZWRFbCwgZG9tTm9kZSlcbiAgICAgICAgICAgIDogUmVhY3RET00ucmVuZGVyKHdyYXBwZWRFbCwgZG9tTm9kZSk7XG4gICAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW5zdGFuY2Uuc2V0Q2hpbGRQcm9wcyhlbC5wcm9wcywgY29udGV4dCwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdW5tb3VudCgpIHtcbiAgICAgICAgUmVhY3RET00udW5tb3VudENvbXBvbmVudEF0Tm9kZShkb21Ob2RlKTtcbiAgICAgICAgaW5zdGFuY2UgPSBudWxsO1xuICAgICAgfSxcbiAgICAgIGdldE5vZGUoKSB7XG4gICAgICAgIGlmICghaW5zdGFuY2UpIHtcbiAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2V0Tm9kZUZyb21Sb290RmluZGVyKFxuICAgICAgICAgIGFkYXB0ZXIuaXNDdXN0b21Db21wb25lbnQsXG4gICAgICAgICAgdG9UcmVlKGluc3RhbmNlLl9yZWFjdEludGVybmFsRmliZXIpLFxuICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgc2ltdWxhdGVFcnJvcihub2RlSGllcmFyY2h5LCByb290Tm9kZSwgZXJyb3IpIHtcbiAgICAgICAgY29uc3QgeyBpbnN0YW5jZTogY2F0Y2hpbmdJbnN0YW5jZSB9ID0gbm9kZUhpZXJhcmNoeVxuICAgICAgICAgIC5maW5kKCh4KSA9PiB4Lmluc3RhbmNlICYmIHguaW5zdGFuY2UuY29tcG9uZW50RGlkQ2F0Y2gpIHx8IHt9O1xuXG4gICAgICAgIHNpbXVsYXRlRXJyb3IoXG4gICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgY2F0Y2hpbmdJbnN0YW5jZSxcbiAgICAgICAgICByb290Tm9kZSxcbiAgICAgICAgICBub2RlSGllcmFyY2h5LFxuICAgICAgICAgIG5vZGVUeXBlRnJvbVR5cGUsXG4gICAgICAgICAgYWRhcHRlci5kaXNwbGF5TmFtZU9mTm9kZSxcbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgICBzaW11bGF0ZUV2ZW50KG5vZGUsIGV2ZW50LCBtb2NrKSB7XG4gICAgICAgIGNvbnN0IG1hcHBlZEV2ZW50ID0gbWFwTmF0aXZlRXZlbnROYW1lcyhldmVudCwgZXZlbnRPcHRpb25zKTtcbiAgICAgICAgY29uc3QgZXZlbnRGbiA9IFRlc3RVdGlscy5TaW11bGF0ZVttYXBwZWRFdmVudF07XG4gICAgICAgIGlmICghZXZlbnRGbikge1xuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYFJlYWN0V3JhcHBlcjo6c2ltdWxhdGUoKSBldmVudCAnJHtldmVudH0nIGRvZXMgbm90IGV4aXN0YCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0L25vLWZpbmQtZG9tLW5vZGVcbiAgICAgICAgZXZlbnRGbihhZGFwdGVyLm5vZGVUb0hvc3ROb2RlKG5vZGUpLCBtb2NrKTtcbiAgICAgIH0sXG4gICAgICBiYXRjaGVkVXBkYXRlcyhmbikge1xuICAgICAgICByZXR1cm4gZm4oKTtcbiAgICAgICAgLy8gcmV0dXJuIFJlYWN0RE9NLnVuc3RhYmxlX2JhdGNoZWRVcGRhdGVzKGZuKTtcbiAgICAgIH0sXG4gICAgICBnZXRXcmFwcGluZ0NvbXBvbmVudFJlbmRlcmVyKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIC4uLnRoaXMsXG4gICAgICAgICAgLi4uZ2V0V3JhcHBpbmdDb21wb25lbnRNb3VudFJlbmRlcmVyKHtcbiAgICAgICAgICAgIHRvVHJlZTogKGluc3QpID0+IHRvVHJlZShpbnN0Ll9yZWFjdEludGVybmFsRmliZXIpLFxuICAgICAgICAgICAgZ2V0TW91bnRXcmFwcGVySW5zdGFuY2U6ICgpID0+IGluc3RhbmNlLFxuICAgICAgICAgIH0pLFxuICAgICAgICB9O1xuICAgICAgfSxcbiAgICB9O1xuICB9XG5cbiAgY3JlYXRlU2hhbGxvd1JlbmRlcmVyKC8qIG9wdGlvbnMgKi8pIHtcbiAgICBjb25zdCBhZGFwdGVyID0gdGhpcztcbiAgICBjb25zdCByZW5kZXJlciA9IG5ldyBTaGFsbG93UmVuZGVyZXIoKTtcbiAgICBsZXQgaXNET00gPSBmYWxzZTtcbiAgICBsZXQgY2FjaGVkTm9kZSA9IG51bGw7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlbmRlcihlbCwgY29udGV4dCwge1xuICAgICAgICBwcm92aWRlclZhbHVlcyA9IG5ldyBNYXAoKSxcbiAgICAgIH0gPSB7fSkge1xuICAgICAgICBjYWNoZWROb2RlID0gZWw7XG4gICAgICAgIC8qIGVzbGludCBjb25zaXN0ZW50LXJldHVybjogMCAqL1xuICAgICAgICBpZiAodHlwZW9mIGVsLnR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgaXNET00gPSB0cnVlO1xuICAgICAgICB9IGVsc2UgaWYgKGlzQ29udGV4dFByb3ZpZGVyKGVsKSkge1xuICAgICAgICAgIHByb3ZpZGVyVmFsdWVzLnNldChlbC50eXBlLCBlbC5wcm9wcy52YWx1ZSk7XG4gICAgICAgICAgY29uc3QgTW9ja1Byb3ZpZGVyID0gT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICAgIChwcm9wcykgPT4gcHJvcHMuY2hpbGRyZW4sXG4gICAgICAgICAgICBlbC50eXBlLFxuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuIHdpdGhTZXRTdGF0ZUFsbG93ZWQoKCkgPT4gcmVuZGVyZXIucmVuZGVyKHsgLi4uZWwsIHR5cGU6IE1vY2tQcm92aWRlciB9KSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaXNDb250ZXh0Q29uc3VtZXIoZWwpKSB7XG4gICAgICAgICAgY29uc3QgUHJvdmlkZXIgPSBhZGFwdGVyLmdldFByb3ZpZGVyRnJvbUNvbnN1bWVyKGVsLnR5cGUpO1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gcHJvdmlkZXJWYWx1ZXMuaGFzKFByb3ZpZGVyKVxuICAgICAgICAgICAgPyBwcm92aWRlclZhbHVlcy5nZXQoUHJvdmlkZXIpXG4gICAgICAgICAgICA6IGdldFByb3ZpZGVyRGVmYXVsdFZhbHVlKFByb3ZpZGVyKTtcbiAgICAgICAgICBjb25zdCBNb2NrQ29uc3VtZXIgPSBPYmplY3QuYXNzaWduKFxuICAgICAgICAgICAgKHByb3BzKSA9PiBwcm9wcy5jaGlsZHJlbih2YWx1ZSksXG4gICAgICAgICAgICBlbC50eXBlLFxuICAgICAgICAgICk7XG4gICAgICAgICAgcmV0dXJuIHdpdGhTZXRTdGF0ZUFsbG93ZWQoKCkgPT4gcmVuZGVyZXIucmVuZGVyKHsgLi4uZWwsIHR5cGU6IE1vY2tDb25zdW1lciB9KSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaXNET00gPSBmYWxzZTtcbiAgICAgICAgICBjb25zdCB7IHR5cGU6IENvbXBvbmVudCB9ID0gZWw7XG5cbiAgICAgICAgICBjb25zdCBpc1N0YXRlZnVsID0gQ29tcG9uZW50LnByb3RvdHlwZSAmJiAoXG4gICAgICAgICAgICBDb21wb25lbnQucHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnRcbiAgICAgICAgICAgIHx8IEFycmF5LmlzQXJyYXkoQ29tcG9uZW50Ll9fcmVhY3RBdXRvQmluZFBhaXJzKSAvLyBmYWxsYmFjayBmb3IgY3JlYXRlQ2xhc3MgY29tcG9uZW50c1xuICAgICAgICAgICk7XG5cbiAgICAgICAgICBpZiAoIWlzU3RhdGVmdWwgJiYgdHlwZW9mIENvbXBvbmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY29uc3Qgd3JhcHBlZEVsID0gT2JqZWN0LmFzc2lnbihcbiAgICAgICAgICAgICAgKC4uLmFyZ3MpID0+IENvbXBvbmVudCguLi5hcmdzKSwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuZXctY2FwXG4gICAgICAgICAgICAgIENvbXBvbmVudCxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICByZXR1cm4gd2l0aFNldFN0YXRlQWxsb3dlZCgoKSA9PiByZW5kZXJlci5yZW5kZXIoeyAuLi5lbCwgdHlwZTogd3JhcHBlZEVsIH0sIGNvbnRleHQpKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHdpdGhTZXRTdGF0ZUFsbG93ZWQoKCkgPT4gcmVuZGVyZXIucmVuZGVyKGVsLCBjb250ZXh0KSk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1bm1vdW50KCkge1xuICAgICAgICByZW5kZXJlci51bm1vdW50KCk7XG4gICAgICB9LFxuICAgICAgZ2V0Tm9kZSgpIHtcbiAgICAgICAgaWYgKGlzRE9NKSB7XG4gICAgICAgICAgcmV0dXJuIGVsZW1lbnRUb1RyZWUoY2FjaGVkTm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gcmVuZGVyZXIuZ2V0UmVuZGVyT3V0cHV0KCk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbm9kZVR5cGU6IG5vZGVUeXBlRnJvbVR5cGUoY2FjaGVkTm9kZS50eXBlKSxcbiAgICAgICAgICB0eXBlOiBjYWNoZWROb2RlLnR5cGUsXG4gICAgICAgICAgcHJvcHM6IGNhY2hlZE5vZGUucHJvcHMsXG4gICAgICAgICAga2V5OiBlbnN1cmVLZXlPclVuZGVmaW5lZChjYWNoZWROb2RlLmtleSksXG4gICAgICAgICAgcmVmOiBjYWNoZWROb2RlLnJlZixcbiAgICAgICAgICBpbnN0YW5jZTogcmVuZGVyZXIuX2luc3RhbmNlLFxuICAgICAgICAgIHJlbmRlcmVkOiBBcnJheS5pc0FycmF5KG91dHB1dClcbiAgICAgICAgICAgID8gZmxhdHRlbihvdXRwdXQpLm1hcCgoZWwpID0+IGVsZW1lbnRUb1RyZWUoZWwpKVxuICAgICAgICAgICAgOiBlbGVtZW50VG9UcmVlKG91dHB1dCksXG4gICAgICAgIH07XG4gICAgICB9LFxuICAgICAgc2ltdWxhdGVFcnJvcihub2RlSGllcmFyY2h5LCByb290Tm9kZSwgZXJyb3IpIHtcbiAgICAgICAgc2ltdWxhdGVFcnJvcihcbiAgICAgICAgICBlcnJvcixcbiAgICAgICAgICByZW5kZXJlci5faW5zdGFuY2UsXG4gICAgICAgICAgY2FjaGVkTm9kZSxcbiAgICAgICAgICBub2RlSGllcmFyY2h5LmNvbmNhdChjYWNoZWROb2RlKSxcbiAgICAgICAgICBub2RlVHlwZUZyb21UeXBlLFxuICAgICAgICAgIGFkYXB0ZXIuZGlzcGxheU5hbWVPZk5vZGUsXG4gICAgICAgICk7XG4gICAgICB9LFxuICAgICAgc2ltdWxhdGVFdmVudChub2RlLCBldmVudCwgLi4uYXJncykge1xuICAgICAgICBjb25zdCBoYW5kbGVyID0gbm9kZS5wcm9wc1twcm9wRnJvbUV2ZW50KGV2ZW50LCBldmVudE9wdGlvbnMpXTtcbiAgICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgICB3aXRoU2V0U3RhdGVBbGxvd2VkKCgpID0+IHtcbiAgICAgICAgICAgIC8vIFRPRE8obG1yKTogY3JlYXRlL3VzZSBzeW50aGV0aWMgZXZlbnRzXG4gICAgICAgICAgICAvLyBUT0RPKGxtcik6IGVtdWxhdGUgUmVhY3QncyBldmVudCBwcm9wYWdhdGlvblxuICAgICAgICAgICAgLy8gUmVhY3RET00udW5zdGFibGVfYmF0Y2hlZFVwZGF0ZXMoKCkgPT4ge1xuICAgICAgICAgICAgaGFuZGxlciguLi5hcmdzKTtcbiAgICAgICAgICAgIC8vIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgYmF0Y2hlZFVwZGF0ZXMoZm4pIHtcbiAgICAgICAgcmV0dXJuIGZuKCk7XG4gICAgICAgIC8vIHJldHVybiBSZWFjdERPTS51bnN0YWJsZV9iYXRjaGVkVXBkYXRlcyhmbik7XG4gICAgICB9LFxuICAgICAgY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBoaWVyYXJjaHkpIHtcbiAgICAgICAgcmV0dXJuIGNoZWNrUHJvcFR5cGVzKFxuICAgICAgICAgIHR5cGVTcGVjcyxcbiAgICAgICAgICB2YWx1ZXMsXG4gICAgICAgICAgbG9jYXRpb24sXG4gICAgICAgICAgZGlzcGxheU5hbWVPZk5vZGUoY2FjaGVkTm9kZSksXG4gICAgICAgICAgKCkgPT4gZ2V0Q29tcG9uZW50U3RhY2soaGllcmFyY2h5LmNvbmNhdChbY2FjaGVkTm9kZV0pKSxcbiAgICAgICAgKTtcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuXG4gIGNyZWF0ZVN0cmluZ1JlbmRlcmVyKG9wdGlvbnMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgcmVuZGVyKGVsLCBjb250ZXh0KSB7XG4gICAgICAgIGlmIChvcHRpb25zLmNvbnRleHQgJiYgKGVsLnR5cGUuY29udGV4dFR5cGVzIHx8IG9wdGlvbnMuY2hpbGRDb250ZXh0VHlwZXMpKSB7XG4gICAgICAgICAgY29uc3QgY2hpbGRDb250ZXh0VHlwZXMgPSB7XG4gICAgICAgICAgICAuLi4oZWwudHlwZS5jb250ZXh0VHlwZXMgfHwge30pLFxuICAgICAgICAgICAgLi4ub3B0aW9ucy5jaGlsZENvbnRleHRUeXBlcyxcbiAgICAgICAgICB9O1xuICAgICAgICAgIGNvbnN0IENvbnRleHRXcmFwcGVyID0gY3JlYXRlUmVuZGVyV3JhcHBlcihlbCwgY29udGV4dCwgY2hpbGRDb250ZXh0VHlwZXMpO1xuICAgICAgICAgIHJldHVybiBSZWFjdERPTVNlcnZlci5yZW5kZXJUb1N0YXRpY01hcmt1cChSZWFjdC5jcmVhdGVFbGVtZW50KENvbnRleHRXcmFwcGVyKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFJlYWN0RE9NU2VydmVyLnJlbmRlclRvU3RhdGljTWFya3VwKGVsKTtcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuXG4gIC8vIFByb3ZpZGVkIGEgYmFnIG9mIG9wdGlvbnMsIHJldHVybiBhbiBgRW56eW1lUmVuZGVyZXJgLiBTb21lIG9wdGlvbnMgY2FuIGJlIGltcGxlbWVudGF0aW9uXG4gIC8vIHNwZWNpZmljLCBsaWtlIGBhdHRhY2hgIGV0Yy4gZm9yIFJlYWN0LCBidXQgbm90IHBhcnQgb2YgdGhpcyBpbnRlcmZhY2UgZXhwbGljaXRseS5cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNsYXNzLW1ldGhvZHMtdXNlLXRoaXMsIG5vLXVudXNlZC12YXJzXG4gIGNyZWF0ZVJlbmRlcmVyKG9wdGlvbnMpIHtcbiAgICBzd2l0Y2ggKG9wdGlvbnMubW9kZSkge1xuICAgICAgY2FzZSBFbnp5bWVBZGFwdGVyLk1PREVTLk1PVU5UOiByZXR1cm4gdGhpcy5jcmVhdGVNb3VudFJlbmRlcmVyKG9wdGlvbnMpO1xuICAgICAgY2FzZSBFbnp5bWVBZGFwdGVyLk1PREVTLlNIQUxMT1c6IHJldHVybiB0aGlzLmNyZWF0ZVNoYWxsb3dSZW5kZXJlcihvcHRpb25zKTtcbiAgICAgIGNhc2UgRW56eW1lQWRhcHRlci5NT0RFUy5TVFJJTkc6IHJldHVybiB0aGlzLmNyZWF0ZVN0cmluZ1JlbmRlcmVyKG9wdGlvbnMpO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFbnp5bWUgSW50ZXJuYWwgRXJyb3I6IFVucmVjb2duaXplZCBtb2RlOiAke29wdGlvbnMubW9kZX1gKTtcbiAgICB9XG4gIH1cblxuICB3cmFwKGVsZW1lbnQpIHtcbiAgICByZXR1cm4gd3JhcChlbGVtZW50KTtcbiAgfVxuXG4gIC8vIGNvbnZlcnRzIGFuIFJTVE5vZGUgdG8gdGhlIGNvcnJlc3BvbmRpbmcgSlNYIFByYWdtYSBFbGVtZW50LiBUaGlzIHdpbGwgYmUgbmVlZGVkXG4gIC8vIGluIG9yZGVyIHRvIGltcGxlbWVudCB0aGUgYFdyYXBwZXIubW91bnQoKWAgYW5kIGBXcmFwcGVyLnNoYWxsb3coKWAgbWV0aG9kcywgYnV0IHNob3VsZFxuICAvLyBiZSBwcmV0dHkgc3RyYWlnaHRmb3J3YXJkIGZvciBwZW9wbGUgdG8gaW1wbGVtZW50LlxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY2xhc3MtbWV0aG9kcy11c2UtdGhpcywgbm8tdW51c2VkLXZhcnNcbiAgbm9kZVRvRWxlbWVudChub2RlKSB7XG4gICAgaWYgKCFub2RlIHx8IHR5cGVvZiBub2RlICE9PSAnb2JqZWN0JykgcmV0dXJuIG51bGw7XG4gICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQobm9kZS50eXBlLCBwcm9wc1dpdGhLZXlzQW5kUmVmKG5vZGUpKTtcbiAgfVxuXG4gIGVsZW1lbnRUb05vZGUoZWxlbWVudCkge1xuICAgIHJldHVybiBlbGVtZW50VG9UcmVlKGVsZW1lbnQpO1xuICB9XG5cbiAgbm9kZVRvSG9zdE5vZGUobm9kZSwgc3VwcG9ydHNBcnJheSA9IGZhbHNlKSB7XG4gICAgY29uc3Qgbm9kZXMgPSBub2RlVG9Ib3N0Tm9kZShub2RlKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShub2RlcykgJiYgIXN1cHBvcnRzQXJyYXkpIHtcbiAgICAgIHJldHVybiBub2Rlc1swXTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGVzO1xuICB9XG5cbiAgZGlzcGxheU5hbWVPZk5vZGUobm9kZSkge1xuICAgIGlmICghbm9kZSkgcmV0dXJuIG51bGw7XG4gICAgY29uc3QgeyB0eXBlLCAkJHR5cGVvZiB9ID0gbm9kZTtcblxuICAgIGNvbnN0IG5vZGVUeXBlID0gdHlwZSB8fCAkJHR5cGVvZjtcblxuICAgIC8vIG5ld2VyIG5vZGUgdHlwZXMgbWF5IGJlIHVuZGVmaW5lZCwgc28gb25seSB0ZXN0IGlmIHRoZSBub2RlVHlwZSBleGlzdHNcbiAgICBpZiAobm9kZVR5cGUpIHtcbiAgICAgIHN3aXRjaCAobm9kZVR5cGUpIHtcbiAgICAgICAgY2FzZSBBc3luY01vZGUgfHwgTmFOOiByZXR1cm4gJ0FzeW5jTW9kZSc7XG4gICAgICAgIGNhc2UgRnJhZ21lbnQgfHwgTmFOOiByZXR1cm4gJ0ZyYWdtZW50JztcbiAgICAgICAgY2FzZSBTdHJpY3RNb2RlIHx8IE5hTjogcmV0dXJuICdTdHJpY3RNb2RlJztcbiAgICAgICAgY2FzZSBQb3J0YWwgfHwgTmFOOiByZXR1cm4gJ1BvcnRhbCc7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgJCR0eXBlb2ZUeXBlID0gdHlwZSAmJiB0eXBlLiQkdHlwZW9mO1xuXG4gICAgc3dpdGNoICgkJHR5cGVvZlR5cGUpIHtcbiAgICAgIGNhc2UgQ29udGV4dENvbnN1bWVyIHx8IE5hTjogcmV0dXJuICdDb250ZXh0Q29uc3VtZXInO1xuICAgICAgY2FzZSBDb250ZXh0UHJvdmlkZXIgfHwgTmFOOiByZXR1cm4gJ0NvbnRleHRQcm92aWRlcic7XG4gICAgICBjYXNlIEZvcndhcmRSZWYgfHwgTmFOOiB7XG4gICAgICAgIGlmICh0eXBlLmRpc3BsYXlOYW1lKSB7XG4gICAgICAgICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmFtZSA9IGRpc3BsYXlOYW1lT2ZOb2RlKHsgdHlwZTogdHlwZS5yZW5kZXIgfSk7XG4gICAgICAgIHJldHVybiBuYW1lID8gYEZvcndhcmRSZWYoJHtuYW1lfSlgIDogJ0ZvcndhcmRSZWYnO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDogcmV0dXJuIGRpc3BsYXlOYW1lT2ZOb2RlKG5vZGUpO1xuICAgIH1cbiAgfVxuXG4gIGlzVmFsaWRFbGVtZW50KGVsZW1lbnQpIHtcbiAgICByZXR1cm4gaXNFbGVtZW50KGVsZW1lbnQpO1xuICB9XG5cbiAgaXNWYWxpZEVsZW1lbnRUeXBlKG9iamVjdCkge1xuICAgIHJldHVybiAhIW9iamVjdCAmJiBpc1ZhbGlkRWxlbWVudFR5cGUob2JqZWN0KTtcbiAgfVxuXG4gIGlzRnJhZ21lbnQoZnJhZ21lbnQpIHtcbiAgICByZXR1cm4gdHlwZU9mTm9kZShmcmFnbWVudCkgPT09IEZyYWdtZW50O1xuICB9XG5cbiAgaXNDdXN0b21Db21wb25lbnQodHlwZSkge1xuICAgIGNvbnN0IGZha2VFbGVtZW50ID0gbWFrZUZha2VFbGVtZW50KHR5cGUpO1xuICAgIHJldHVybiAhIXR5cGUgJiYgKFxuICAgICAgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbidcbiAgICAgIHx8IGlzRm9yd2FyZFJlZihmYWtlRWxlbWVudClcbiAgICAgIHx8IGlzQ29udGV4dFByb3ZpZGVyKGZha2VFbGVtZW50KVxuICAgICAgfHwgaXNDb250ZXh0Q29uc3VtZXIoZmFrZUVsZW1lbnQpXG4gICAgKTtcbiAgfVxuXG4gIGlzQ29udGV4dENvbnN1bWVyKHR5cGUpIHtcbiAgICByZXR1cm4gISF0eXBlICYmIGlzQ29udGV4dENvbnN1bWVyKG1ha2VGYWtlRWxlbWVudCh0eXBlKSk7XG4gIH1cblxuICBpc0N1c3RvbUNvbXBvbmVudEVsZW1lbnQoaW5zdCkge1xuICAgIGlmICghaW5zdCB8fCAhdGhpcy5pc1ZhbGlkRWxlbWVudChpbnN0KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5pc0N1c3RvbUNvbXBvbmVudChpbnN0LnR5cGUpO1xuICB9XG5cbiAgZ2V0UHJvdmlkZXJGcm9tQ29uc3VtZXIoQ29uc3VtZXIpIHtcbiAgICBjb25zdCB7IFByb3ZpZGVyIH0gPSBDb25zdW1lciB8fCB7fTtcbiAgICBpZiAoUHJvdmlkZXIpIHtcbiAgICAgIHJldHVybiBQcm92aWRlcjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFbnp5bWUgSW50ZXJuYWwgRXJyb3I6IGNhbuKAmXQgZmlndXJlIG91dCBob3cgdG8gZ2V0IFByb3ZpZGVyIGZyb20gQ29uc3VtZXInKTtcbiAgfVxuXG4gIGNyZWF0ZUVsZW1lbnQoLi4uYXJncykge1xuICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KC4uLmFyZ3MpO1xuICB9XG5cbiAgd3JhcFdpdGhXcmFwcGluZ0NvbXBvbmVudChub2RlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIFJvb3RGaW5kZXIsXG4gICAgICBub2RlOiB3cmFwV2l0aFdyYXBwaW5nQ29tcG9uZW50KFJlYWN0LmNyZWF0ZUVsZW1lbnQsIG5vZGUsIG9wdGlvbnMpLFxuICAgIH07XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFNpeHRlZW5UaHJlZUFkYXB0ZXI7XG4iXX0=
//# sourceMappingURL=ReactSixteenThreeAdapter.js.map